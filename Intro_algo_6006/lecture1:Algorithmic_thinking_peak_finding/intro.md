# 6.006

- Administrative details.
- Course overview.
- Peak finding problem.

## Professors:
- Srini Devadas.
- Eric Domane.

### Context:
6.006: A course to have fun time learning variety of algorithms. 

### Administrative details:
Just go to the website: <https://coursescsail.mit.edu/6.006> and read it, to get all information we need about what this class is about from a standpoint of syllabus.

### Course overview:
We are going to dive right in and look at a particular problem of peak finding, both the one dimensional version and a two dimensional version, and talk about algorithms to solve this peak finding problem both varieties of it. And notice that there are differences between these various algorithms that we will look at in terms of their complexity, which means that we are going to have different run times of these algorithms depending of inputs size, based on how efficient these algorithms are. We will apply asymptotic complexity, and for this lecture we will analyze relatively simple algorithms in terms of algorithm complexity, and we will able to compare and say that a particular algorithm is faster than other one, assuming large inputs, because, it's asymptotically less complex.

Efficient procedures for solving problems on "large inputs". Like:
- US highway system. A map of all of the highways in the US.
- Human genome.
- Social network working into Facebook.

Current age concerns:
- Efficiency is a concern to solve large inputs.  
- Scalability: Because the concept of "large" changes along with time, and what was considered large now, it'll not be in the next years to come. We want to know how our algorithms are going to behave as the inputs are getting larger and larger.
- Classic data structures, like binary search trees, hashes tables (dictionaries in Python), etc, and data structures such as balanced binary search trees that are more efficient than the regular binary search trees. 
- Classical algorithms like the Bubble sort, selection sort, insertion sort, etc, and matching and so on.
- Real implementation in Python.

### Content:
This course has 8 modules:
- Algorithmic thinking (this lecture), peak finding problem.
- Sorting & trees: Event simulation.
- Hashing: Genome comparison.
- Numerics: RSA encryption.
- Graphs: Rubik's cube. The minimum number of moves necessary to go from a given starting configuration to the final end configuration, where all of the faces have a uniform color.
- Shortest paths: Caltech -- CSail - MIT.
- Dynamic programming: Image compression.
- Advanced topics.
